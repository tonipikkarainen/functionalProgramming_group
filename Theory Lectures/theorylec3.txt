Interaction lecture 3


Q1
Mark these either as True or False:
  String                          False
  Bool -> String                  True
  Int -> Bool -> String           False
  (Int -> Bool -> String) Int     False

Perustelu: f on funktio, joka ottaa parametriksi yhden Intin ja yhden Boolin.
Jos x on Int-tyyppinen, jäljelle jää funktio, joka tarvii vielä parametriksi Bool-
muuttujan ja joka palauttaa Stringin.

Q2
Mark these either as True or False:
  Int                  False
  Bool                 False
  Int -> Bool          True
  Int -> Int -> Bool   False

Perustelu: Jotta funktiossa olisi mitään järkeä, x:n täytyy olla tyyppiä Int.
Tällöin loppuosasta even (x+1) tulee Bool ja kokonaisuudesta Int -> Bool.

Q3
Mark these either as True or False:
  (Int -> Int -> Int) -> Int -> [Int] -> Int      True
  (Int -> Bool -> Int) -> Bool -> [Int] -> Bool   True
  (Int -> Bool -> Int) -> Bool -> Int -> Bool     False
  (Int -> Bool -> Int) -> Int -> Bool -> Int      False

  Perustelu: a-muuttujien pitää olla keskenään samaa tyyppiä ja samoin b-muuttujien
  keskenään. a ja b voivat olla silti myös samoja. Listojen täytyy pysyä myös oikeilla paikoilla.

Q4
Mark these either as True or False:

The function sad has a type error (type should be a function)
Function argument cannot have a forall a. type, but let-bound variable can
Function argument can have a forall a. type, but let-bound variable can't

1 False
2 True
3 False

Perustelu: let-lauseessa voi olla forall-tyyppi, muusta en ole varma.

Q5
Mark these either as True or False:
  Ei voi                                            True
  Kyllä voi, mutta sitä lauseketta ei voi laskea    False
  Kyllä voi ja voi myös laskea!                     False



Q6
Mark these either as True or False:
  f :: forall a. Bool -> a        False
  g :: forall a. a -> Bool        True
  h :: forall a b. (b -> a) -> a  False
  j :: forall a b. b -> (a -> b)  True

Q7
Mark these either as True or False:

Because you can always make a function that returns True for all inputs
Because you can always check if the argument (of type a) is null and return True/False based on that
Function can return True if it is given an argument and False otherwise
Anything can be converted to a Bool. E.g., 1=True and 0=False

True
False
False
False



Q8
Mark these either as True or False:
  (\ f xs -> ...) :: forall a. (a->a) -> [a] -> [a]
  (\xs -> \x -> ...) :: forall a. [a] -> (a->a)      False
  (\xs -> \y -> ...) :: forall a b. [b] -> (a->a)    
  (\xs -> \ f -> ...) ::forall a. [a] -> (a->a) -> [a]
