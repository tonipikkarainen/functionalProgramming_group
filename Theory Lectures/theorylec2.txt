Q0 How do you parenthesise
\x -> x <*> \y -> y / 2 ?
Mark these either as True or False:
    \x -> (x <*> (\y -> (y / 2))) True
    ((\x -> x) <*> (\y -> y)) / 2 False
    (\x -> x) <*> ((\y -> y ) / 2) False

Vastaus: True, False, False

Q1 You have just defined data Participant = Student String Int | Teacher String
and list participants :: [Participant]. Which structure would be most suitable for
a) Checking that there are atleast 5 participants (in the list), and
b) Checking that if a participant a teacher
Mark these either as True or False:
    a) if, b) if    False
    a) if, b) case  True
    a) case, b) if  False
    a) case, b) case False

Q1 Vastaus:  Joka tapauksessa b-kohdassa pitää testata sekä
vaihtoehto että osallistuja on opettaja että se, että se on oppilas.
Se onnistuu parhaiten case-rakenteella. Listan pituuden testaaminen lienee helpointa
if-lauseella.

Q2 Which of these are the same as [1,2,3]?
Mark these either as True or False:
    1:2:3    False
    1:[2:3]  False
    1:2:[3]  True
    1:2:3:[] True

Q2 Vastaus: Paitsi niissä pitäisi olla sulut?

Q3
How do you create a value of type ListOf?
data ListOf a = Null | Cons a (ListOf a)
Mark these either as True or False:
    Null                True
    ListOf [1,2,3]      False
    Cons 4 (ListOf a)   False
    Cons 5 (Cons 6 (Null))  True
    let l = Cons 1 l in l   False

Q3 Vastaus: ListOf a voi saada arvon Null tai sitten Cons a (ListOf a) mukaan rakennetun.

Q4
What does
case Just (Left 1) of
    Nothing        -> "A"
    Just (Right 1) -> "B"
    Just x         -> "C"
    Just (Left 1)  -> "D"
evaluate to?
Mark these either as True or False:
    "A"   False
    "B"   False
    "C"   True
    "D"   False

Q4 Vastaus: Case-lauseesta mätsää ensimmäinen sopiva ylhäältä päin lähtiessä,
tässä tapauksessa Just x.

Q5
What constructors are defined here?
data PyType = PyBool Bool
            | PyInt Int
            | PyDouble Double
            | PyFun ([PyType] -> IO PyType)

Mark these either as True or False:
    PyType False
    PyBool True
    Bool    False
    PyFun   True

Q5 Vastaus: PyType on tyyppi ja Bool annetaan konstruktorille parametrina.

Q6
What is the type of PyFun given:
data PyType = PyBool Bool
            | PyInt Int
            | PyDouble Double
            | PyFun ([PyType] -> IO PyType)

Mark these either as True or False:
    PyFun :: [PyType] -> IO PyType             False
    PyFun :: ([PyType] -> IO PyType) -> PyType True
    PyFun :: [PyType] -> IO PyType -> PyType   False
    Constructors don't have a type             False

Q6 Vastaus: PyFun määritellään funktioksi [PyType] -> IO PyType joka saa PyType-
tyyppisen arvon.

Q7
data PyType = PyBool Bool
            | PyInt Int
            | PyDouble Double
            | PyFun ([PyType] -> IO PyType)

What is the type of PyFun boo if PyFun boo is well typed?
Mark these either as True or False:
    PyFun boo :: [PyType] -> IO PyType    False
    PyFun boo :: IO PyType         False
    PyFun boo :: PyType           True

Q7 Vastaus: Sama perustelu kuin edellisessä.

Q8
How would you define LoginResult in
checkUserLogin :: User -> SessionCookie -> LoginResult
(e.g for a function that handles logging in to this web page)
Mark these either as True or False:
    type LoginResult = Bool           False
    type LoginResult = Maybe UserInfo True
    type LoginResult = (UserInfo,Bool) False
    type LoginResult = String           False

Q8 Vastaus: Jos kirjautuminen onnistuu, palautetaan käyttäjätiedot, jos ei,
palautetaan Nothing.
