L3_Q1_2018_1
Let's review how function application is typed. Given that

f :: Int -> Bool -> String
x :: Int
what is f x

Mark these either as True or False:
String F

Bool -> String T

Int -> Bool -> String F

(Int -> Bool -> String) Int F

f:lle annetaan vaan yksi argumentti joten tuloksena on uusi funktio, jonka tyyppi on sellainen että se ottaa jäljelle jäävän parametrin (Bool) ja tuottaa alkuperäisen tuloksen String.

L3_Q2_2018_1
Suppose that even :: Int -> Bool. What then, is the type of

\x -> even (x+1)
Mark these either as True or False:
Int F

Bool F

Int -> Bool T

Int -> Int -> Bool F

Parametrin x täytyy olla tyyppiä Int, koska se +1 menee even:in argumentiksi joka sitten palauttaa tyypin Bool. Siksi kyseisen funktion tyyppi on Int -> Bool.

L3_Q3_2018_1
Which are proper specializations of forall a b. (a -> b -> a) -> b -> [a] -> b?

Mark these either as True or False:
(Int -> Int -> Int) -> Int -> [Int] -> Int T

(Int -> Bool -> Int) -> Bool -> [Int] -> Bool T

(Int -> Bool -> Int) -> Bool -> Int -> Bool F

(Int -> Bool -> Int) -> Int -> Bool -> Int F

Kolmannessa kohdassa puuttuu lista-tyyppi, ja neljännessä a on sekä bool että int (+lista puuttuu.)

L3_Q4_2018_1
Why does fun work and sad doesn't?

fun :: [Double]
fun = let x = 3 in take x (repeat x)
sad :: [Double]
sad = (\x -> take x (repeat x)) 3
-- take :: Int -> [a] -> [a]
-- repeat :: a -> [a]
Mark these either as True or False:
The function sad has a type error (type should be a function) 

Function argument cannot have a forall a. type, but let-bound variable can T

Function argument can have a forall a. type, but let-bound variable can't T

Sanoisin, että johtuu siitä, että let vaihtoehdossa x:n tyyppi on forall a. Num a => a, joka voi sitten olla Int tai Double tilanteesta riippuen. Alemmassa vaihtoehdossa numero 3 sitten kiinnittyy Int:ksi. Mutta ylimmästä väittämästä (tyypin pitäisi olla funktio) en ole ihan varma..?

L3_Q5_2018_1
Based on what you know about polytypes, can you write a Haskell expression with the type forall a. a?

Mark these either as True or False:
Ei voi F

Kyllä voi, mutta sitä lauseketta ei voi laskea T

Kyllä voi ja voi myös laskea! F

Kokeiluni perusteella voi tehdä, jos asettaa ekspression arvoksi "undefined". Tällä ei voi kuitenkaan laskea mitään. Sitten jos määritellään, että a kuuluu esim. tyyppiluokkaan Num a, niin voidaan laskea tällä arvolla. Luulisin, että tämä on niin, että ekspressiolla täytyy olla joku tarkempi määritelmä sen tyypistä, jotta kääntäjä pystyy tietämään mitä sen arvolla voi tehdä.

L3_Q6_2018_1
Which of the types below can be given a proper implementation? (ie. aside from error, infinite recursion, etc.)

Mark these either as True or False:
f :: forall a. Bool -> a F

g :: forall a. a -> Bool T 

h :: forall a b. (b -> a) -> a F 

j :: forall a b. b -> (a -> b) T

h on false, koska argumenttina tulee funktio, jonka palauttama tyyppi pitäisi laskea, että voitaisiin palauttaa sama tyyppi. Tuota laskua ei voi tehdä jos a:n tyyppi ei ole spesifioitu. f on false, koska ei tiedetä mikä palautettavan arvon tyyppi on. g on True, koska voidaan palauttaa yksikäsitteinen tyyppi millä tahansa syötteellä. j on true koska voidaan antaa parametrina mitä tahansa ja palauttaa niistä ensimmäinen, jolloin tiedetään, mikä on palautettavan arvon tyyppiluokka.

L3_Q7_2018_1
Why is it possible to implement forall a. a -> Bool but not forall a. Bool -> a?

Mark these either as True or False:
Because you can always make a function that returns True for all inputs T

Because you can always check if the argument (of type a) is null and return True/False based on that F

Function can return True if it is given an argument and False otherwise F

Anything can be converted to a Bool. E.g., 1=True and 0=False F

Emme voi tehdä mitään laskuja funktion argumentilla, kun sille ei ole spesifioitu tyyppiä. Ja funktio ei palauta tyyppinsä mukaista tyyppiä ellei sille anneta argumenttia. Jos sille ei anneta argumenttia sen tyyppi on edelleen a -> Bool


L3_Q8_2018_1
We know that function with type forall a. a -> a is always an identity function. How about if the term a->a appears inside a bigger type? Must the corresponding argument/result be an identity function in the types below?

Mark these either as True or False:
(\ f xs -> ...) :: forall a. (a->a) -> [a] -> [a] F (on mahdollista saada ensimmäisenä parametrina olevan funktion argumentin tyyppi toisesta parametrista, joten pystytään laskemaan sillä)

(\xs -> \x -> ...) :: forall a. [a] -> (a->a) puoliksi F (voidaan ottaa vaikka ensimmäinen alkio listasta, jolloin ei siis ole identiteetti funktio toisen parametrin näkökulmasta. Jos lista on tyhjä pitää olla identiteettifunktio.)

(\xs -> \y -> ...) :: forall a b. [b] -> (a->a) T

(\xs -> \ f -> ...) ::forall a. [a] -> (a->a) -> [a] F (voidaan tehdä samanlainen toteutus kuin ensimmäisessä kohdassa. esim. g xs f = map f xs)
